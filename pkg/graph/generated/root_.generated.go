// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/guidewire/fern-reporter/pkg/graph/modelv2"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		TestRun     func(childComplexity int, testRunFilter modelv2.TestRunFilter) int
		TestRunByID func(childComplexity int, id int) int
		TestRuns    func(childComplexity int, first *int, after *string, desc *bool) int
	}

	SpecRun struct {
		EndTime         func(childComplexity int) int
		ID              func(childComplexity int) int
		Message         func(childComplexity int) int
		SpecDescription func(childComplexity int) int
		StartTime       func(childComplexity int) int
		Status          func(childComplexity int) int
		SuiteID         func(childComplexity int) int
		Tags            func(childComplexity int) int
	}

	SuiteRun struct {
		EndTime   func(childComplexity int) int
		ID        func(childComplexity int) int
		SpecRuns  func(childComplexity int) int
		StartTime func(childComplexity int) int
		SuiteName func(childComplexity int) int
		TestRunID func(childComplexity int) int
	}

	Tag struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	TestRun struct {
		BuildTriggerActor func(childComplexity int) int
		BuildURL          func(childComplexity int) int
		EndTime           func(childComplexity int) int
		GitBranch         func(childComplexity int) int
		GitSha            func(childComplexity int) int
		ID                func(childComplexity int) int
		StartTime         func(childComplexity int) int
		SuiteRuns         func(childComplexity int) int
		TestProjectName   func(childComplexity int) int
		TestSeed          func(childComplexity int) int
	}

	TestRunConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TestRunEdge struct {
		Cursor  func(childComplexity int) int
		TestRun func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.testRun":
		if e.complexity.Query.TestRun == nil {
			break
		}

		args, err := ec.field_Query_testRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TestRun(childComplexity, args["testRunFilter"].(modelv2.TestRunFilter)), true

	case "Query.testRunById":
		if e.complexity.Query.TestRunByID == nil {
			break
		}

		args, err := ec.field_Query_testRunById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TestRunByID(childComplexity, args["id"].(int)), true

	case "Query.testRuns":
		if e.complexity.Query.TestRuns == nil {
			break
		}

		args, err := ec.field_Query_testRuns_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TestRuns(childComplexity, args["first"].(*int), args["after"].(*string), args["desc"].(*bool)), true

	case "SpecRun.endTime":
		if e.complexity.SpecRun.EndTime == nil {
			break
		}

		return e.complexity.SpecRun.EndTime(childComplexity), true

	case "SpecRun.id":
		if e.complexity.SpecRun.ID == nil {
			break
		}

		return e.complexity.SpecRun.ID(childComplexity), true

	case "SpecRun.message":
		if e.complexity.SpecRun.Message == nil {
			break
		}

		return e.complexity.SpecRun.Message(childComplexity), true

	case "SpecRun.specDescription":
		if e.complexity.SpecRun.SpecDescription == nil {
			break
		}

		return e.complexity.SpecRun.SpecDescription(childComplexity), true

	case "SpecRun.startTime":
		if e.complexity.SpecRun.StartTime == nil {
			break
		}

		return e.complexity.SpecRun.StartTime(childComplexity), true

	case "SpecRun.status":
		if e.complexity.SpecRun.Status == nil {
			break
		}

		return e.complexity.SpecRun.Status(childComplexity), true

	case "SpecRun.suiteId":
		if e.complexity.SpecRun.SuiteID == nil {
			break
		}

		return e.complexity.SpecRun.SuiteID(childComplexity), true

	case "SpecRun.tags":
		if e.complexity.SpecRun.Tags == nil {
			break
		}

		return e.complexity.SpecRun.Tags(childComplexity), true

	case "SuiteRun.endTime":
		if e.complexity.SuiteRun.EndTime == nil {
			break
		}

		return e.complexity.SuiteRun.EndTime(childComplexity), true

	case "SuiteRun.id":
		if e.complexity.SuiteRun.ID == nil {
			break
		}

		return e.complexity.SuiteRun.ID(childComplexity), true

	case "SuiteRun.specRuns":
		if e.complexity.SuiteRun.SpecRuns == nil {
			break
		}

		return e.complexity.SuiteRun.SpecRuns(childComplexity), true

	case "SuiteRun.startTime":
		if e.complexity.SuiteRun.StartTime == nil {
			break
		}

		return e.complexity.SuiteRun.StartTime(childComplexity), true

	case "SuiteRun.suiteName":
		if e.complexity.SuiteRun.SuiteName == nil {
			break
		}

		return e.complexity.SuiteRun.SuiteName(childComplexity), true

	case "SuiteRun.testRunId":
		if e.complexity.SuiteRun.TestRunID == nil {
			break
		}

		return e.complexity.SuiteRun.TestRunID(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "TestRun.buildTriggerActor":
		if e.complexity.TestRun.BuildTriggerActor == nil {
			break
		}

		return e.complexity.TestRun.BuildTriggerActor(childComplexity), true

	case "TestRun.buildUrl":
		if e.complexity.TestRun.BuildURL == nil {
			break
		}

		return e.complexity.TestRun.BuildURL(childComplexity), true

	case "TestRun.endTime":
		if e.complexity.TestRun.EndTime == nil {
			break
		}

		return e.complexity.TestRun.EndTime(childComplexity), true

	case "TestRun.gitBranch":
		if e.complexity.TestRun.GitBranch == nil {
			break
		}

		return e.complexity.TestRun.GitBranch(childComplexity), true

	case "TestRun.gitSha":
		if e.complexity.TestRun.GitSha == nil {
			break
		}

		return e.complexity.TestRun.GitSha(childComplexity), true

	case "TestRun.id":
		if e.complexity.TestRun.ID == nil {
			break
		}

		return e.complexity.TestRun.ID(childComplexity), true

	case "TestRun.startTime":
		if e.complexity.TestRun.StartTime == nil {
			break
		}

		return e.complexity.TestRun.StartTime(childComplexity), true

	case "TestRun.suiteRuns":
		if e.complexity.TestRun.SuiteRuns == nil {
			break
		}

		return e.complexity.TestRun.SuiteRuns(childComplexity), true

	case "TestRun.testProjectName":
		if e.complexity.TestRun.TestProjectName == nil {
			break
		}

		return e.complexity.TestRun.TestProjectName(childComplexity), true

	case "TestRun.testSeed":
		if e.complexity.TestRun.TestSeed == nil {
			break
		}

		return e.complexity.TestRun.TestSeed(childComplexity), true

	case "TestRunConnection.edges":
		if e.complexity.TestRunConnection.Edges == nil {
			break
		}

		return e.complexity.TestRunConnection.Edges(childComplexity), true

	case "TestRunConnection.pageInfo":
		if e.complexity.TestRunConnection.PageInfo == nil {
			break
		}

		return e.complexity.TestRunConnection.PageInfo(childComplexity), true

	case "TestRunConnection.totalCount":
		if e.complexity.TestRunConnection.TotalCount == nil {
			break
		}

		return e.complexity.TestRunConnection.TotalCount(childComplexity), true

	case "TestRunEdge.cursor":
		if e.complexity.TestRunEdge.Cursor == nil {
			break
		}

		return e.complexity.TestRunEdge.Cursor(childComplexity), true

	case "TestRunEdge.testRun":
		if e.complexity.TestRunEdge.TestRun == nil {
			break
		}

		return e.complexity.TestRunEdge.TestRun(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputTestRunFilter,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/schema.graphql", Input: `type Tag {
  id: Int
  name: String
}

type SpecRun {
  id: Int
  suiteId: Int
  specDescription: String
  status: String
  message: String
  startTime: String
  endTime: String
  tags: [Tag]
}

type SuiteRun {
  id: Int!
  testRunId: Int!
  suiteName: String
  startTime: String
  endTime: String
  specRuns: [SpecRun]
}

type TestRun {
  id: Int!
  testProjectName: String
  testSeed: Int
  startTime: String
  endTime: String
  gitBranch: String
  gitSha: String
  buildTriggerActor: String
  buildUrl: String
  suiteRuns: [SuiteRun!]!
}

input TestRunFilter {
  id: Int
  testProjectName: String
}

type Query {
  testRuns(first: Int, after: String, desc: Boolean): TestRunConnection!
  testRun(testRunFilter: TestRunFilter!): [TestRun!]!
  testRunById(id: Int!): TestRun
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type TestRunEdge {
  cursor: String!
  testRun: TestRun!
}

type TestRunConnection {
  edges: [TestRunEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
